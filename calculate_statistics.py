import csv
import matplotlib.pyplot as plt
import sys 
import numpy as np
from datetime import datetime
from scipy.stats import mannwhitneyu

# this file used to calculate statistics from the csv files generated by the experiments and to plot the results
# the csv files have the following format:
# time, algorithm, execution_time, collisions (list of pairs, action and number of collisions), 
# cpu_time_total, execution_time_per_step (list of times), cpu_time_per_step (list of times), number of levels



def get_time(row):
    return float(row.split('.')[0][1:])

    # convert the string to a float
    # row = float(row)

    # return eval(row)
labels = ["steps_lrtdp", "steps_lrtdp_pwm", "steps_tsp_current_occupancy_with_replanning"]
levels = [2,5,8]


def get_collisions(row):
    collisions_local = 0
    # row = list(row)
    row = eval(row)
    # convert the string to a list of tuples
    # print(row)
    # print("row:", row)
    for x in row:
        # print("x[1]:", x)
        # print(type(x))
        collisions_local = collisions_local + int(x[1])
    # print("collisions", collisions_local)
    return collisions_local
        



def parse_row(row):
    time = get_time(row[0])
    algorithm = row[1]
    execution_time = float(row[2])
    collisions = get_collisions(row[3])
    cpu_time_total = float(datetime.strptime(row[4], "%H:%M:%S.%f").microsecond / 1000000 + datetime.strptime(row[4], "%H:%M:%S.%f").second + datetime.strptime(row[4], "%H:%M:%S.%f").minute * 60 + datetime.strptime(row[4], "%H:%M:%S.%f").hour * 3600)
    execution_time_per_step = eval(row[5])
    cpu_time_per_step = eval(row[6])
    number_of_levels = int(row[7])
    return time, algorithm, execution_time, collisions, cpu_time_total, execution_time_per_step, cpu_time_per_step, number_of_levels

    
def process_row(row, planning_time_lrtdp_per_step_per_level, cpu_time, cpu_time_first_planning, collisions, execution_time):
    time, algorithm_local, execution_time_local, collisions_local, cpu_time_total_local, execution_time_per_step_local, cpu_time_per_step_local, number_of_levels_local = parse_row(row)
    if len(cpu_time_per_step_local) != 0:
        for i in range(0, len(cpu_time_per_step_local)):
            if str(i) not in planning_time_lrtdp_per_step_per_level[str(number_of_levels_local)]:
                planning_time_lrtdp_per_step_per_level[str(number_of_levels_local)][str(i)] = []
            planning_time_lrtdp_per_step_per_level[str(number_of_levels_local)][str(i)].append(float(cpu_time_per_step_local[i]))
    cpu_time[algorithm_local][str(number_of_levels_local)].append(float(cpu_time_total_local))
    cpu_time_first_planning[algorithm_local][str(number_of_levels_local)].append(float(cpu_time_per_step_local[0]) if len(cpu_time_per_step_local) > 0 else 0)
    collisions[algorithm_local][str(number_of_levels_local)].append(collisions_local)
    execution_time[algorithm_local][str(number_of_levels_local)].append(float(execution_time_local))



def get_statistics(csv_file_tsp, csv_file_lrtdp, max_levels = 8, csv_file_lrtdp_pwm=None):
    print("Reading csv files", csv_file_tsp, "and", csv_file_lrtdp)
    data_tsp = []
    data_lrtdp = []
    data_lrtdp_pwm = []
    with open(csv_file_tsp, 'r') as file:
        reader = csv.reader(file)
        # next(reader)
        data_tsp = [row for row in reader]
    with open(csv_file_lrtdp, 'r') as file:
        reader = csv.reader(file)
        # next(reader)
        data_lrtdp = [row for row in reader]
    if csv_file_lrtdp_pwm is not None:
        print("Reading csv file for lrtdp pwm", csv_file_lrtdp_pwm)
        with open(csv_file_lrtdp_pwm, 'r') as file:
            reader = csv.reader(file)
            # next(reader)
            data_lrtdp_pwm = [row for row in reader]

    
    lrtdp_count = 0
    time_equal = 0
    time_best_tsp = 0
    row_count = 0
    num_rows = 4
    collisions_better_lrtdp = []
    collisions_better_tsp = []
    time_delta_better_lrtdp = []
    time_delta_better_tsp = []
    time_delta_min_lrtdp = 99999999
    time_delta_max_lrtdp = -99999999
    time_delta_min_tsp = 99999999
    time_delta_max_tsp = -99999999
    planning_time_lrtdp_per_step_per_level = {}
    planning_time_lrtdp_pwm_per_step_per_level = {}

    times = []
    execution_time = {}
    cpu_time = {}
    cpu_time_first_planning = {}
    collisions = {}
    # labels = ["steps_avg", "steps_min", "steps_max", "steps_curr", "steps_lrtdp", "steps_lrtdp_pwm"]
    # num_rows = len(labels)
    num_tsp_rows = 1
    for label in labels:
        execution_time[label] = {}
        cpu_time[label] = {}
        collisions[label] = {}
        cpu_time_first_planning[label] = {}
        for i in levels:
            execution_time[label][str(i)] = []
            cpu_time[label][str(i)] = []
            cpu_time_first_planning[label][str(i)] = []
            collisions[label][str(i)] = []
            planning_time_lrtdp_per_step_per_level[str(i)] = {}
            planning_time_lrtdp_pwm_per_step_per_level[str(i)] = {}
    for i in range(0, len(data_lrtdp), len(levels)):
        times.append(float(data_lrtdp[i][0]))
    times = set(times)
    # print(len(data_lrtdp), "rows in the csv file", csv_file_lrtdp)
    # count the number of times:

    for row_id in range(0, len(data_lrtdp)):
        
        if "FAILURE" in data_lrtdp[row_id][3] or \
           "FAILURE" in data_tsp[row_id][3]:
            print("Skipping row", row_id, "due to FAILURE in lrtdp")
            continue
        if "FAILURE" in data_tsp[row_id][3]:
            print("Skipping row", row_id, "due to FAILURE in tsp")
            continue
        if csv_file_lrtdp_pwm is not None and ("FAILURE" in data_lrtdp_pwm[row_id][3]):
            print("Skipping row", row_id, "due to FAILURE in lrtdp pwm")
            continue
        
        # print("Processing row", row_id, "of", len(data_lrtdp))
        ## PROCESS LRTDP RESULTS


        process_row(data_lrtdp[row_id], planning_time_lrtdp_per_step_per_level, cpu_time, cpu_time_first_planning, collisions, execution_time)
        process_row(data_tsp[row_id], planning_time_lrtdp_per_step_per_level, cpu_time, cpu_time_first_planning, collisions, execution_time)
        if csv_file_lrtdp_pwm is not None:
            print("Processing row", row_id, "for lrtdp pwm")
            process_row(data_lrtdp_pwm[row_id], planning_time_lrtdp_pwm_per_step_per_level, cpu_time, cpu_time_first_planning, collisions, execution_time)

        time_lrtdp = get_time(data_lrtdp[row_id][0])
        time_tsp = get_time(data_tsp[row_id][0])
        if csv_file_lrtdp_pwm is not None:
            time_lrtdp_pwm = get_time(data_lrtdp_pwm[row_id][0])
        else:
            time_lrtdp_pwm = None

        collisions

        ### evaluation
        if time_lrtdp < time_tsp:
            lrtdp_count += 1
            time_delta_better_lrtdp.append(time_tsp - time_lrtdp)
            if time_tsp - time_lrtdp < time_delta_min_lrtdp:
                time_delta_min_lrtdp = time_tsp - time_lrtdp
            if time_tsp - time_lrtdp > time_delta_max_lrtdp:
                time_delta_max_lrtdp = time_tsp - time_lrtdp
        elif time_lrtdp > time_tsp:
            time_best_tsp += 1
            time_delta_better_tsp.append(time_lrtdp - time_tsp)
            if time_lrtdp - time_tsp < time_delta_min_tsp:
                time_delta_min_tsp = time_lrtdp - time_tsp
            if time_lrtdp - time_tsp > time_delta_max_tsp:
                time_delta_max_tsp = time_lrtdp - time_tsp
        elif time_lrtdp == time_tsp:
            time_equal += 1

    # print (collisions["steps_lrtdp"])
    print ("---- DONE READING CSV FILE ----")
    # print("execution time", execution_time)
    print(execution_time)

    print ("---- p-values ----")
    for i in levels:

        p = mannwhitneyu( execution_time["steps_lrtdp"][str(i)], execution_time["steps_tsp_current_occupancy_with_replanning"][str(i)], alternative='less')
        print("p-value lrtdp tsp level", i, p[1])
        if csv_file_lrtdp_pwm is not None:
            p = mannwhitneyu( execution_time["steps_lrtdp_pwm"][str(i)], execution_time["steps_tsp_current_occupancy_with_replanning"][str(i)], alternative='less')
            print("p-value lrtdp pwm tsp level", i, p[1])
        p = mannwhitneyu( collisions["steps_lrtdp"][str(i)], collisions["steps_tsp_current_occupancy_with_replanning"][str(i)], alternative='less')
        print("p-value collisions lrtdp tsp level", i, p[1])
        if csv_file_lrtdp_pwm is not None:
             p = mannwhitneyu( collisions["steps_lrtdp_pwm"][str(i)], collisions["steps_tsp_current_occupancy_with_replanning"][str(i)], alternative='less')
             print("p-value collisions lrtdp pwm tsp level", i, p[1])
    
    print("----- DONE CALCULATING p-values ----")
    for i in levels:

        print("Average execution time for tsp level", i, np.mean(execution_time["steps_tsp_current_occupancy_with_replanning"][str(i)]))
        print("Average execution time for lrtdp level", i, np.mean(execution_time["steps_lrtdp"][str(i)]))
        print("Average number of collisions for tsp level", i, np.mean(collisions["steps_tsp_current_occupancy_with_replanning"][str(i)]))
        print("Average number of collisions for lrtdp level", i, np.mean(collisions["steps_lrtdp"][str(i)]))


    print("---- DONE CALCULATING STATISTICS ----")
    print("Number of times lrtdp was faster than tsp:", lrtdp_count)
    print("Number of times tsp was faster than lrtdp:", time_best_tsp)
    print("Number of times lrtdp and tsp had the same execution time:", time_equal)
    print("number of times collisions better tsp ", len(collisions_better_tsp))
    print("number of times collisions better lrtdp ", len(collisions_better_lrtdp))
    # print("Minimum time delta for lrtdp:", np.min(time_delta_min_lrtdp))
    # print("Maximum time delta for lrtdp:", np.max(time_delta_max_lrtdp))
    # print("Minimum time delta for tsp:", time_delta_min_tsp)
    # print("Maximum time delta for tsp:", time_delta_max_tsp)   
    # print("Average time delta for lrtdp:", np.mean(time_delta_better_lrtdp))
    # print("Average time delta for tsp:", np.mean(time_delta_better_tsp))
    # labels = [key for key in execution_time.keys()]
    plot_planning_time__per_levels = False
    plot_execution_time_per_levels = True
    plot_planning_time_per_levels = True
    plot_collisions_per_levels = False
    if plot_planning_time__per_levels:
        for i in levels:
            fig = plt.figure(figsize =(10, 7))
            ax = fig.add_subplot(111)
            ax.set_title(csv_file_tsp.split("/")[-1].split(".")[0] + " planning time per step (level " + str(i) + ")", fontsize=20)
            # set y-axis scale to be multiple of 3
            max_y = np.max([np.max(planning_time_lrtdp_per_step_per_level[str(i)][str(x)]) for x in planning_time_lrtdp_per_step_per_level[str(i)].keys()])
            plt.yticks(np.arange(0, max_y + 2, step=20))
            max_steps = len(planning_time_lrtdp_per_step_per_level[str(i)].keys())
            data = [planning_time_lrtdp_per_step_per_level[str(i)][str(x)] for x in range(0, max_steps)]
            ax.boxplot(data, tick_labels = [str(x) for x in range(1, max_steps+1)])
            plt.ylabel("Planning time per step (s)", fontsize=20)
            plt.xlabel("Step", fontsize=20)
            # set text size of x and y labels

            plt.xticks(fontsize=20)
            plt.yticks(fontsize=12)
            plt.grid()
            plt.show()

    # plot the execution time for the lrtdp and tsp algorithms for each level
    if plot_execution_time_per_levels:
        for i in levels:
            fig = plt.figure(figsize =(10, 7))
            ax = fig.add_subplot(111)
            ax.set_title(csv_file_tsp.split("/")[-1].split(".")[0] + " execution time (level " + str(i) + ") (first planning + max(planning, execution))", fontsize=20)
            # set only first planning time 
            # data = [execution_time[label][str(i)] for label in labels if label != "steps_lrtdp_pwm"]
            data = [execution_time[label][str(i)] for label in labels]
            # print("data for level", i, data)
            # labels = ["tsp_avg", "tsp_min", "tsp_max", "tsp_curr", "lrtdp"]
            ax.boxplot(data, tick_labels = labels)
            plt.ylabel("Execution time (s)", fontsize=20)
            plt.xlabel("Algorithms", fontsize=20)
            # set text size of x and y labels 
            plt.xticks(fontsize=20)
            plt.yticks(fontsize=12)

            plt.grid()
            plt.show()


    # plot the planning time for the execution of the lrtdp and tsp algorithms for each level
    if plot_planning_time_per_levels:
        for i in levels:
            fig = plt.figure(figsize =(10, 7))
            ax = fig.add_subplot(111)
            ax.set_title(csv_file_tsp.split("/")[-1].split(".")[0] + " planning time (level " + str(i) + ")", fontsize=20)
            data = [cpu_time[label][str(i)] for label in labels]
            print("planning time data for level", i, data)
            # data = [cpu_time["steps_avg"][str(i)], cpu_time["steps_min"][str(i)], cpu_time["steps_max"][str(i)], cpu_time["steps_curr"][str(i)], cpu_time["steps_lrtdp"][str(i)]]
            # labels = ["tsp_avg", "tsp_min", "tsp_max", "tsp_curr", "lrtdp"]
            ax.boxplot(data, tick_labels = labels)
            plt.ylabel("Planning time (s)", fontsize=20)
            plt.xlabel("Algorithms", fontsize=20)
            plt.grid()
            plt.show()

    # plot the number of collisions for the execution of the lrtdp and tsp algorithms for each level
    if plot_collisions_per_levels:
        for i in levels:
            fig = plt.figure(figsize =(10, 7))
            ax = fig.add_subplot(111)
            ax.set_title(csv_file_tsp.split("/")[-1].split(".")[0] + " number of collisions (level " + str(i) + ")")
            data = [collisions[label][str(i)] for label in labels]
            ax.boxplot(data, tick_labels = labels)
            plt.ylabel("Number of collisions")
            plt.xlabel("Algorithms")
            plt.grid()
            plt.show()



def plot_cpu_times_per_number_of_vertices(csv_file_tsp):
    cpu_times_per_level = {}
    for j in [11, 16, 21]:
        cpu_times_per_level[str(j)] = []
        with open(csv_file_tsp.split(".")[0] + "_" + str(j) + "_lrtdp.csv", 'r') as file:
            reader = csv.reader(file)
            next(reader)
            data = [row for row in reader]
        for row in data:
            times_lrtdp = eval(row[-2])

            if len(times_lrtdp) != 0:
                for i in range(0, len(times_lrtdp)):
                    if str(j) not in cpu_times_per_level:
                        cpu_times_per_level[str(j)] = []
                    cpu_times_per_level[str(j)].append(float(times_lrtdp[i]))
    print(cpu_times_per_level)

    ## PLOT

    fig = plt.figure(figsize =(10, 7))
    ax = fig.add_subplot(111)
    ax.set_title("Planning time (average)")
    data = []
    labels_local = []
    for j in [11, 16, 21]:
        data.append(cpu_times_per_level[str(j)])
        labels_local.append(str(j))
    ax.boxplot(data, tick_labels = labels_local)
    plt.ylabel("Planning time (s)")
    plt.xlabel("Algorithms")
    plt.grid()
    plt.show()



    print("---- DONE PLOTTING ----")

def print_usage():
    print("Usage: python calculate_statistics.py statistics <csv_file_tsp> <csv_file_lrtdp> <max_levels> [--lrtdp_pwm_file <csv_file_lrtdp_pwm>]")
    print("or: python calculate_statistics.py times <csv_file_tsp>")



if __name__ == '__main__':
    # get_statistics("steps_iit_time_iter.csv")
    # get_statistics("steps_small_occupancy_map_atc_corridor_mixed.csv")
    # get_statistics("steps_medium_occupancy_map_atc_corridor_mixed.csv")
    if len(sys.argv) < 2:
        print_usage()
        sys.exit(1)
    if sys.argv[1] == "statistics":
        if "--lrtdp_file" in sys.argv:
            lrtdp_file_index = sys.argv.index("--lrtdp_file")
            if lrtdp_file_index + 1 >= len(sys.argv):
                print("Error: --lrtdp_file requires a value")
                sys.exit(1)
            lrtdp_file = sys.argv[lrtdp_file_index + 1]
        else:
            sys.exit("Error: --lrtdp_file argument is required for statistics command")
            sys.exit(1)

        if "--lrtdp_pwm_file" in sys.argv:
            lrtdp_pwm_file_index = sys.argv.index("--lrtdp_pwm_file")
            if lrtdp_pwm_file_index + 1 >= len(sys.argv):
                print("Error: --lrtdp_pwm_file requires a value")
                sys.exit(1)
            lrtdp_pwm_file = sys.argv[lrtdp_pwm_file_index + 1]
            print("lrtdp_pwm_file", lrtdp_pwm_file)
        else:
            lrtdp_pwm_file = None

        if "--tsp_file" in sys.argv:
            tsp_file_index = sys.argv.index("--tsp_file")
            if tsp_file_index + 1 >= len(sys.argv):
                print("Error: --tsp_file requires a value")
                sys.exit(1)
            tsp_file = sys.argv[tsp_file_index + 1]
        else:
            sys.exit("Error: --tsp_file argument is required for statistics command")
            sys.exit(1)

        if "--max_levels" in sys.argv:
            max_levels_index = sys.argv.index("--max_levels")
            if max_levels_index + 1 >= len(sys.argv):
                print("Error: --max_levels requires a value")
                sys.exit(1)
            max_levels = int(sys.argv[max_levels_index + 1])
        else:
            print_usage()
            sys.exit(1)
        print("tsp_file", tsp_file)
        print("lrtdp_file", lrtdp_file)
        print("max_levels", max_levels)
        print("lrtdp_pwm_file", lrtdp_pwm_file)
        get_statistics(csv_file_tsp=tsp_file, csv_file_lrtdp=lrtdp_file, max_levels=max_levels, csv_file_lrtdp_pwm=lrtdp_pwm_file)
    elif sys.argv[1] == "times":
        plot_cpu_times_per_number_of_vertices(sys.argv[2])
    else:
        print("Unknown command", sys.argv[1])
        print("Usage: python calculate_statistics.py statistics <csv_file_tsp> <max_levels>")
        print("or: python calculate_statistics.py times <csv_file_tsp>")
